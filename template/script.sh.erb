#!/usr/bin/env bash

# NOTE: We intentionally don't use 'set -e' globally because we want to handle 
# errors gracefully in many places. Critical sections use explicit error checking.

# OOD session output dir. This is where connection.yml must live.
SESSION_ROOT="$(pwd)"
SESSION_UUID="$(basename "${SESSION_ROOT}")"

# Stable pointer location in user home
OOD_STATE_DIR="${HOME}/.ood/cryosparc"
ACTIVE_PTR="${OOD_STATE_DIR}/active_connection_path"

mkdir -p "${OOD_STATE_DIR}"

echo "==========================================="
echo "  CryoSPARC Starting"
echo "  User: ${USER}"
echo "  Date: $(date)"
echo "  Script PID: $$"
echo "  Session root: ${SESSION_ROOT}"
echo "  Session uuid: ${SESSION_UUID}"
echo "==========================================="

# Write pointer immediately so view can always locate the right file
echo "${SESSION_ROOT}/connection.yml" > "${ACTIVE_PTR}"
chmod 600 "${ACTIVE_PTR}" || true

# Helper. atomic write connection.yml in session dir
write_connection_yml() {
  local status="$1"
  local host_fqdn="$2"
  local host_short="$3"
  local web_port="$4"
  local data_dir="$5"
  local project_dir="$6"
  local gpus="$7"

  local tmp="${SESSION_ROOT}/connection.yml.tmp"
  cat > "${tmp}" << EOF
---
status: "${status}"
session_uuid: "${SESSION_UUID}"
written_at: "$(date -Is)"
host: "${host_fqdn}"
hostname_short: "${host_short}"
port: "${web_port}"
data_dir: "${data_dir}"
project_dir: "${project_dir}"
gpus: "${gpus}"
user: "${USER}"
EOF
  mv -f "${tmp}" "${SESSION_ROOT}/connection.yml"
}

# Write an initial "starting" record so the view never shows stale data
HOST_FQDN="$(hostname -f 2>/dev/null || hostname)"
HOST_SHORT="$(hostname -s 2>/dev/null || hostname)"
[[ "$HOST_FQDN" != *.* ]] && HOST_FQDN="${HOST_SHORT}.cm.cluster"

# Port allocation (same as before)
get_user_base_port() {
    local username="$1"
    local hash
    hash=$(echo -n "$username" | md5sum | cut -c1-4)
    local hash_int=$((16#$hash))
    local port_offset=$((hash_int % 2000))
    echo $((40000 + (port_offset * 10)))
}
BASE_PORT=$(get_user_base_port "${USER}")
WEB_PORT="${BASE_PORT}"

# Form variables
LICENSE_ID="<%= context.license_id.to_s.strip %>"
USER_DATA_DIR="<%= context.cryosparc_data_dir.to_s.strip %>"
PROJECT_DIR="<%= context.project_dir.to_s.strip %>"
USER_EMAIL="<%= context.email.to_s.strip %>"
FORM_PASSWORD="<%= context.password.to_s.strip %>"

# If user_data_dir is empty in the form, define a sane default
if [ -z "${USER_DATA_DIR}" ]; then
  USER_DATA_DIR="/lustre/nvwulf/scratch/${USER}/cryosparc_data"
fi
if [ -z "${PROJECT_DIR}" ]; then
  PROJECT_DIR="/lustre/nvwulf/scratch/${USER}/cryosparc_projects"
fi

# ============================================================
# VALIDATION: Check for required fields
# ============================================================
USER_DB_DIR="${USER_DATA_DIR}/database"
FRESH_INSTALL=false
if [ ! -f "${USER_DB_DIR}/WiredTiger" ]; then
  FRESH_INSTALL=true
fi

# License ID is required for fresh installs
if [ "${FRESH_INSTALL}" = true ] && [ -z "${LICENSE_ID}" ]; then
    echo ""
    echo "=============================================="
    echo "  ERROR: License ID Required"
    echo "=============================================="
    echo "  This is your first time running CryoSPARC."
    echo "  You must provide your personal License ID."
    echo ""
    echo "  Get a FREE academic license at:"
    echo "  https://cryosparc.com/download"
    echo "=============================================="
    exit 1
fi

# Email is required for fresh installs
if [ "${FRESH_INSTALL}" = true ] && [ -z "${USER_EMAIL}" ]; then
    echo ""
    echo "=============================================="
    echo "  ERROR: Email Required"
    echo "=============================================="
    echo "  This is your first time running CryoSPARC."
    echo "  You must provide an email address for login."
    echo "=============================================="
    exit 1
fi

GPU_COUNT=$(nvidia-smi --query-gpu=index --format=csv,noheader 2>/dev/null | wc -l || echo "0")

write_connection_yml "starting" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"

echo "Pointer written: ${ACTIVE_PTR}"
echo "Initial connection.yml written: ${SESSION_ROOT}/connection.yml"

# ------------------------------------------------------------
# SHARED INSTALLATION PATH (read-only for users)
# ------------------------------------------------------------
export CRYOSPARC_ROOT="/lustre/nvwulf/software/cryosparc/4.7.1"
SHARED_MASTER_DIR="${CRYOSPARC_ROOT}/cryosparc_master"
SHARED_WORKER_DIR="${CRYOSPARC_ROOT}/cryosparc_worker"

# Verify shared installation exists
if [ ! -d "${SHARED_MASTER_DIR}" ]; then
    echo ""
    echo "=============================================="
    echo "  ERROR: CryoSPARC Installation Not Found"
    echo "=============================================="
    echo "  Expected: ${SHARED_MASTER_DIR}"
    echo "  Please contact your system administrator."
    echo "=============================================="
    exit 1
fi

# ------------------------------------------------------------
# PER-USER INSTANCE DIRECTORY (using symlinks for speed!)
# This creates a lightweight per-user structure where most
# content is symlinked to the shared installation, but
# certain directories that need write access are COPIED:
#   - bin/           (scripts that resolve paths)
#   - run/           (logs and PIDs) 
#   - deps_hashes/   (install.sh writes hash files here)
# And these are CREATED fresh:
#   - config.sh      (per-user configuration)
# ------------------------------------------------------------
USER_INSTANCE_DIR="${USER_DATA_DIR}/cryosparc_instance"
USER_MASTER_DIR="${USER_INSTANCE_DIR}/cryosparc_master"
USER_WORKER_DIR="${USER_INSTANCE_DIR}/cryosparc_worker"

# List of directories/files that MUST be writable (copied, not symlinked)
# Add any new directories here if you encounter permission errors
WRITABLE_DIRS="bin run deps_hashes"
SKIP_FILES="config.sh"

echo ""
echo "=============================================="
echo "  Setting up per-user CryoSPARC instance"
echo "=============================================="
echo "  Shared installation: ${CRYOSPARC_ROOT}"
echo "  User instance: ${USER_INSTANCE_DIR}"
echo "  Fresh install: ${FRESH_INSTALL}"
echo "=============================================="

# Function to check if item should be copied (writable) instead of symlinked
should_copy() {
    local item_name="$1"
    for dir in ${WRITABLE_DIRS}; do
        if [ "${item_name}" = "${dir}" ]; then
            return 0  # true, should copy
        fi
    done
    return 1  # false, should symlink
}

# Function to check if item should be skipped entirely (we create it ourselves)
should_skip() {
    local item_name="$1"
    for f in ${SKIP_FILES}; do
        if [ "${item_name}" = "${f}" ]; then
            return 0  # true, should skip
        fi
    done
    return 1  # false, should not skip
}

# Function to create a symlinked directory structure
create_symlinked_instance() {
    local src_dir="$1"
    local dst_dir="$2"
    local dir_name
    dir_name=$(basename "$src_dir")
    
    echo "Creating symlinked instance of ${dir_name}..."
    
    # Create the destination directory
    mkdir -p "${dst_dir}"
    
    # Use find to get all items (handles spaces and special chars better)
    find "${src_dir}" -maxdepth 1 -mindepth 1 | while read -r item; do
        local item_name
        item_name=$(basename "$item")
        local dst_item="${dst_dir}/${item_name}"
        
        # Skip if already exists
        if [ -e "${dst_item}" ] || [ -L "${dst_item}" ]; then
            continue
        fi
        
        # Check if we should skip this item entirely
        if should_skip "${item_name}"; then
            echo "  Skipping ${item_name} (will create custom)"
            continue
        fi
        
        # Check if this needs to be copied (writable) or symlinked
        if should_copy "${item_name}"; then
            if [ -d "${item}" ]; then
                echo "  Copying ${item_name}/ directory"
                cp -r "${item}" "${dst_item}"
            else
                echo "  Copying ${item_name} file"
                cp "${item}" "${dst_item}"
            fi
        else
            # Symlink everything else
            ln -s "${item}" "${dst_item}"
        fi
    done
    
    # Ensure run directory exists even if not in source
    mkdir -p "${dst_dir}/run"
    
    echo "  Instance created in ${dst_dir}"
}

# Function to verify and fix an existing instance
verify_and_fix_instance() {
    local src_dir="$1"
    local dst_dir="$2"
    local dir_name
    dir_name=$(basename "$src_dir")
    
    echo "Verifying ${dir_name} instance..."
    
    # Ensure run directory exists
    mkdir -p "${dst_dir}/run"
    
    # Check all items that should be copied (not symlinked)
    for dir_name in ${WRITABLE_DIRS}; do
        local src_item="${src_dir}/${dir_name}"
        local dst_item="${dst_dir}/${dir_name}"
        
        # Skip if source doesn't exist
        [ -e "${src_item}" ] || continue
        
        # Fix if it's a symlink (should be a real copy)
        if [ -L "${dst_item}" ]; then
            echo "  Fixing ${dir_name}/ (was symlink, needs to be writable)..."
            rm -f "${dst_item}"
            if [ -d "${src_item}" ]; then
                cp -r "${src_item}" "${dst_item}"
            else
                cp "${src_item}" "${dst_item}"
            fi
        elif [ ! -e "${dst_item}" ]; then
            echo "  Creating missing ${dir_name}/..."
            if [ -d "${src_item}" ]; then
                cp -r "${src_item}" "${dst_item}"
            else
                cp "${src_item}" "${dst_item}"
            fi
        fi
    done
    
    # Check for any missing symlinks and create them
    find "${src_dir}" -maxdepth 1 -mindepth 1 | while read -r item; do
        local item_name
        item_name=$(basename "$item")
        local dst_item="${dst_dir}/${item_name}"
        
        # Skip items we handle specially
        if should_skip "${item_name}" || should_copy "${item_name}"; then
            continue
        fi
        
        # Create symlink if missing
        if [ ! -e "${dst_item}" ] && [ ! -L "${dst_item}" ]; then
            echo "  Adding missing symlink: ${item_name}"
            ln -s "${item}" "${dst_item}"
        fi
        
        # Check for broken symlinks and fix them
        if [ -L "${dst_item}" ] && [ ! -e "${dst_item}" ]; then
            echo "  Fixing broken symlink: ${item_name}"
            rm -f "${dst_item}"
            ln -s "${item}" "${dst_item}"
        fi
    done
}

# Create or verify per-user master directory
if [ ! -d "${USER_MASTER_DIR}" ]; then
    create_symlinked_instance "${SHARED_MASTER_DIR}" "${USER_MASTER_DIR}"
else
    echo "Using existing per-user master directory"
    verify_and_fix_instance "${SHARED_MASTER_DIR}" "${USER_MASTER_DIR}"
fi

# Create or verify per-user worker directory
if [ ! -d "${USER_WORKER_DIR}" ]; then
    create_symlinked_instance "${SHARED_WORKER_DIR}" "${USER_WORKER_DIR}"
else
    echo "Using existing per-user worker directory"
    verify_and_fix_instance "${SHARED_WORKER_DIR}" "${USER_WORKER_DIR}"
fi

# Now use the per-user directories
export CRYOSPARC_MASTER_DIR="${USER_MASTER_DIR}"
export CRYOSPARC_WORKER_DIR="${USER_WORKER_DIR}"
export PATH="${CRYOSPARC_MASTER_DIR}/bin:${CRYOSPARC_WORKER_DIR}/bin:${PATH}"

MASTER_DIR="${CRYOSPARC_MASTER_DIR}"
WORKER_DIR="${CRYOSPARC_WORKER_DIR}"

echo ""
echo "=============================================="
echo "  GRACEFUL CLEANUP: Stopping CryoSPARC"
echo "=============================================="

# ============================================================
# ISSUE 2 FIX: Graceful shutdown before force kill
# Give MongoDB time to shutdown cleanly to prevent corruption
# ============================================================

# Step 1: Try graceful stop first
echo "Attempting graceful shutdown..."
cd "${MASTER_DIR}" 2>/dev/null && ./bin/cryosparcm stop 2>/dev/null || true

# Step 2: Wait for graceful shutdown (up to 30 seconds)
echo "Waiting for graceful shutdown..."
for i in $(seq 1 30); do
    if ! pgrep -u "${USER}" -f "mongod.*cryosparc" > /dev/null 2>&1; then
        echo "MongoDB stopped gracefully after ${i} seconds"
        break
    fi
    sleep 1
done

# Step 3: Send SIGTERM (graceful) to remaining processes
echo "Sending SIGTERM to remaining processes..."
pkill -u "${USER}" -f "cryosparc_master/bin" 2>/dev/null || true
pkill -u "${USER}" -f "cryosparc_worker/bin" 2>/dev/null || true
pkill -u "${USER}" -f "cryosparc_compute" 2>/dev/null || true
pkill -u "${USER}" -f "cryosparcm" 2>/dev/null || true
pkill -u "${USER}" -f "cryosparcw" 2>/dev/null || true
pkill -u "${USER}" -f "mongod.*cryosparc" 2>/dev/null || true
pkill -u "${USER}" -f "supervisord.*cryosparc" 2>/dev/null || true

# Step 4: Wait for SIGTERM to take effect
sleep 10

# Step 5: Only force kill (-9) if processes still exist
if pgrep -u "${USER}" -f "mongod.*cryosparc" > /dev/null 2>&1; then
    echo "WARNING: MongoDB still running, force killing..."
    pkill -9 -u "${USER}" -f "mongod.*cryosparc" 2>/dev/null || true
    sleep 3
fi

if pgrep -u "${USER}" -f "cryosparc" > /dev/null 2>&1; then
    echo "WARNING: CryoSPARC processes still running, force killing..."
    pkill -9 -u "${USER}" -f "cryosparc_master/bin" 2>/dev/null || true
    pkill -9 -u "${USER}" -f "cryosparc_worker/bin" 2>/dev/null || true
    pkill -9 -u "${USER}" -f "cryosparc_compute" 2>/dev/null || true
    pkill -9 -u "${USER}" -f "cryosparcm" 2>/dev/null || true
    pkill -9 -u "${USER}" -f "cryosparcw" 2>/dev/null || true
    pkill -9 -u "${USER}" -f "supervisord.*cryosparc" 2>/dev/null || true
    sleep 3
fi

# Clean up socket and lock files
rm -f /tmp/cryosparc-supervisor-*.sock 2>/dev/null || true
rm -f "${HOME}/.cryosparc/"*.sock 2>/dev/null || true
rm -f "${USER_MASTER_DIR}/run/"*.pid 2>/dev/null || true
rm -f "${USER_MASTER_DIR}/run/"*.sock 2>/dev/null || true

echo "Cleanup complete"
echo ""

# ============================================================
# ROBUST DATABASE RECOVERY
# Handle all cases of improper shutdown, corruption, locks
# ============================================================
echo "=============================================="
echo "  Database Integrity Check & Recovery"
echo "=============================================="

if [ -d "${USER_DB_DIR}" ]; then
    DB_REPAIR_NEEDED=false
    
    # ----------------------------------------------------
    # Step 1: Kill any orphaned MongoDB processes for this user
    # ----------------------------------------------------
    ORPHAN_MONGOD=$(pgrep -u "${USER}" -f "mongod.*${USER_DB_DIR}" 2>/dev/null || true)
    if [ -n "${ORPHAN_MONGOD}" ]; then
        echo "WARNING: Found orphaned MongoDB process(es): ${ORPHAN_MONGOD}"
        echo "  Killing orphaned processes..."
        pkill -u "${USER}" -f "mongod.*${USER_DB_DIR}" 2>/dev/null || true
        sleep 3
        pkill -9 -u "${USER}" -f "mongod.*${USER_DB_DIR}" 2>/dev/null || true
        sleep 2
    fi
    
    # ----------------------------------------------------
    # Step 2: Remove ALL lock files unconditionally
    # These are always safe to remove if MongoDB isn't running
    # ----------------------------------------------------
    echo "Cleaning lock files..."
    rm -f "${USER_DB_DIR}/mongod.lock" 2>/dev/null || true
    rm -f "${USER_DB_DIR}/WiredTiger.lock" 2>/dev/null || true
    rm -f "${USER_DB_DIR}/.lock" 2>/dev/null || true
    
    # ----------------------------------------------------
    # Step 3: Check for corruption indicators
    # ----------------------------------------------------
    CORRUPTION_DETECTED=false
    
    # Check if WiredTiger file exists but is empty (truly corrupted)
    # Note: Normal WiredTiger file is 40-50 bytes, so only flag if very small
    if [ -f "${USER_DB_DIR}/WiredTiger" ]; then
        WT_SIZE=$(stat -c%s "${USER_DB_DIR}/WiredTiger" 2>/dev/null || echo "0")
        if [ "${WT_SIZE}" -lt 20 ]; then
            echo "WARNING: WiredTiger file appears corrupted (size: ${WT_SIZE} bytes)"
            CORRUPTION_DETECTED=true
        fi
    fi
    
    # Check for WiredTiger.turtle which indicates incomplete recovery
    if [ -f "${USER_DB_DIR}/WiredTiger.turtle" ]; then
        if [ -f "${USER_DB_DIR}/WiredTiger.turtle.set" ]; then
            echo "WARNING: Found incomplete WiredTiger recovery files"
            rm -f "${USER_DB_DIR}/WiredTiger.turtle.set" 2>/dev/null || true
            DB_REPAIR_NEEDED=true
        fi
    fi
    
    # Check journal directory
    if [ -d "${USER_DB_DIR}/journal" ]; then
        JOURNAL_FILES=$(ls -1 "${USER_DB_DIR}/journal/" 2>/dev/null | wc -l)
        if [ "${JOURNAL_FILES}" -gt 0 ]; then
            echo "Found ${JOURNAL_FILES} journal files (will be replayed on startup)"
        fi
    fi
    
    # Clean up diagnostic.data if too large
    if [ -d "${USER_DB_DIR}/diagnostic.data" ]; then
        DIAG_SIZE=$(du -sm "${USER_DB_DIR}/diagnostic.data" 2>/dev/null | cut -f1)
        if [ "${DIAG_SIZE:-0}" -gt 100 ]; then
            echo "Cleaning old diagnostic files (${DIAG_SIZE}MB)..."
            find "${USER_DB_DIR}/diagnostic.data" -type f -mtime +3 -delete 2>/dev/null || true
        fi
    fi
    
    # ----------------------------------------------------
    # Step 4: If corruption detected, try MongoDB repair
    # ----------------------------------------------------
    if [ "${CORRUPTION_DETECTED}" = true ]; then
        echo ""
        echo "=============================================="
        echo "  Attempting Database Repair..."
        echo "=============================================="
        
        # Find mongod binary - follow symlinks and check multiple locations
        MONGOD_BIN=""
        
        # First try to resolve through the symlinked deps directory
        if [ -L "${USER_MASTER_DIR}/deps" ]; then
            REAL_DEPS=$(readlink -f "${USER_MASTER_DIR}/deps")
            if [ -x "${REAL_DEPS}/mongodb/bin/mongod" ]; then
                MONGOD_BIN="${REAL_DEPS}/mongodb/bin/mongod"
            fi
        fi
        
        # Fall back to explicit paths
        if [ -z "${MONGOD_BIN}" ]; then
            for try_path in \
                "${SHARED_MASTER_DIR}/deps/mongodb/bin/mongod" \
                "${CRYOSPARC_ROOT}/cryosparc_master/deps/mongodb/bin/mongod" \
                "/lustre/nvwulf/software/cryosparc/4.7.1/cryosparc_master/deps/mongodb/bin/mongod" \
                "${USER_MASTER_DIR}/deps/mongodb/bin/mongod"; do
                if [ -x "${try_path}" ]; then
                    MONGOD_BIN="${try_path}"
                    break
                fi
            done
        fi
        
        if [ -n "${MONGOD_BIN}" ] && [ -x "${MONGOD_BIN}" ]; then
            echo "Found mongod at: ${MONGOD_BIN}"
            echo "Running MongoDB repair (this may take a few minutes)..."
            timeout 300 "${MONGOD_BIN}" --dbpath "${USER_DB_DIR}" --repair 2>&1 | tail -20 || true
            echo "Repair attempt completed"
        else
            echo "WARNING: Could not find mongod binary for repair"
            echo "  MongoDB will attempt automatic journal recovery on startup"
        fi
    fi
    
    # ----------------------------------------------------
    # Step 4b: If database is severely corrupted, offer nuclear option
    # ----------------------------------------------------
    if [ -f "${USER_DB_DIR}/WiredTiger" ]; then
        WT_SIZE=$(stat -c%s "${USER_DB_DIR}/WiredTiger" 2>/dev/null || echo "0")
        if [ "${WT_SIZE}" -lt 10 ]; then
            echo ""
            echo "=============================================="
            echo "  SEVERE DATABASE CORRUPTION DETECTED"
            echo "=============================================="
            echo "  WiredTiger metadata is only ${WT_SIZE} bytes."
            echo "  Database may not be recoverable."
            echo ""
            echo "  If CryoSPARC fails to start, you may need to:"
            echo "  rm -rf ${USER_DB_DIR}"
            echo "  Then restart - you'll lose job history but"
            echo "  project files in ${PROJECT_DIR} are safe."
            echo "=============================================="
        fi
    fi
    
    # ----------------------------------------------------
    # Step 5: Create backup marker for tracking
    # ----------------------------------------------------
    echo "$(date -Is) - Session started, integrity check complete" >> "${USER_DATA_DIR}/session_log.txt"
    
    echo "Database integrity check complete ✓"
    
    # ----------------------------------------------------
    # Step 6: Quick database startup test
    # Start MongoDB briefly to verify it can start
    # ----------------------------------------------------
    echo "Running database pre-flight check..."
    
    # Find mongod binary - follow symlinks
    MONGOD_BIN=""
    
    if [ -L "${USER_MASTER_DIR}/deps" ]; then
        REAL_DEPS=$(readlink -f "${USER_MASTER_DIR}/deps")
        if [ -x "${REAL_DEPS}/mongodb/bin/mongod" ]; then
            MONGOD_BIN="${REAL_DEPS}/mongodb/bin/mongod"
        fi
    fi
    
    if [ -z "${MONGOD_BIN}" ]; then
        for try_path in \
            "${SHARED_MASTER_DIR}/deps/mongodb/bin/mongod" \
            "${CRYOSPARC_ROOT}/cryosparc_master/deps/mongodb/bin/mongod" \
            "/lustre/nvwulf/software/cryosparc/4.7.1/cryosparc_master/deps/mongodb/bin/mongod"; do
            if [ -x "${try_path}" ]; then
                MONGOD_BIN="${try_path}"
                break
            fi
        done
    fi
    
    if [ -n "${MONGOD_BIN}" ] && [ -x "${MONGOD_BIN}" ]; then
        # Try to start MongoDB briefly to verify database is OK
        TEST_LOG="/tmp/mongod_test_${USER}_$$.log"
        timeout 30 "${MONGOD_BIN}" \
            --dbpath "${USER_DB_DIR}" \
            --port $((BASE_PORT + 100)) \
            --bind_ip 127.0.0.1 \
            --logpath "${TEST_LOG}" \
            --fork 2>/dev/null
        
        TEST_PID=$(pgrep -u "${USER}" -f "mongod.*$((BASE_PORT + 100))" 2>/dev/null || true)
        
        if [ -n "${TEST_PID}" ]; then
            echo "  Pre-flight check passed ✓"
            kill "${TEST_PID}" 2>/dev/null || true
            sleep 2
            kill -9 "${TEST_PID}" 2>/dev/null || true
        else
            # Check if there was a startup error
            if [ -f "${TEST_LOG}" ] && grep -q "exception\|error\|fatal" "${TEST_LOG}" 2>/dev/null; then
                echo "  WARNING: Database pre-flight detected issues:"
                grep -i "exception\|error\|fatal" "${TEST_LOG}" | head -5
                echo ""
                echo "  Attempting recovery..."
                
                # Try repair one more time
                timeout 300 "${MONGOD_BIN}" --dbpath "${USER_DB_DIR}" --repair 2>&1 | tail -10 || true
            else
                echo "  Pre-flight check completed (MongoDB may have recovered journals)"
            fi
        fi
        rm -f "${TEST_LOG}" 2>/dev/null || true
    else
        echo "  Skipping pre-flight (mongod not found)"
    fi
else
    echo "No existing database found (fresh install)"
fi

# ----------------------------------------------------
# Create a simple backup of critical database files
# This runs in background and won't slow down startup
# ----------------------------------------------------
backup_database() {
    local backup_dir="${USER_DATA_DIR}/database_backup"
    mkdir -p "${backup_dir}"
    
    while true; do
        sleep 1800  # Every 30 minutes
        
        if [ -d "${USER_DB_DIR}" ] && pgrep -u "${USER}" -f "mongod.*${USER_DB_DIR}" > /dev/null 2>&1; then
            # Only backup small critical files, not the full database
            cp -f "${USER_DB_DIR}/WiredTiger" "${backup_dir}/" 2>/dev/null || true
            cp -f "${USER_DB_DIR}/WiredTiger.turtle" "${backup_dir}/" 2>/dev/null || true
            cp -f "${USER_DB_DIR}/storage.bson" "${backup_dir}/" 2>/dev/null || true
            echo "$(date -Is) - Backup checkpoint" >> "${USER_DATA_DIR}/session_log.txt"
        fi
    done
}

# Start background backup (won't prevent script from exiting)
backup_database &
BACKUP_PID=$!
disown ${BACKUP_PID} 2>/dev/null || true

echo ""
echo "=============================================="
echo "  Port Allocation for user '${USER}'"
echo "=============================================="
echo "  Base Port:  ${BASE_PORT}"
echo "  Web UI:     Port ${WEB_PORT}"
echo "=============================================="

echo "Checking if ports are available..."
for port in ${BASE_PORT} $((BASE_PORT+1)) $((BASE_PORT+2)); do
    if ss -tuln 2>/dev/null | grep -q ":${port} "; then
        echo "WARNING: Port ${port} still in use, waiting..."
        sleep 5
    fi
done
echo "Ports ready!"

SSD_CACHE="/lustre/nvwulf/scratch/${USER}/cryosparc_cache"
mkdir -p "${USER_DATA_DIR}" "${USER_DB_DIR}" "${PROJECT_DIR}" "${SSD_CACHE}"

# Create the per-user config.sh in the user's master directory
# This is the key file that install.sh tries to write to!
cat > "${USER_MASTER_DIR}/config.sh" << EOF
export CRYOSPARC_LICENSE_ID="${LICENSE_ID}"
export CRYOSPARC_MASTER_HOSTNAME="${HOST_FQDN}"
export CRYOSPARC_DB_PATH="${USER_DB_DIR}"
export CRYOSPARC_BASE_PORT=${BASE_PORT}
export CRYOSPARC_DEVELOP=false
export CRYOSPARC_INSECURE=true
export CRYOSPARC_FORCE_HOSTNAME=true
export CRYOSPARC_FORCE_USER=true
EOF

# Also create config.sh for the worker
cat > "${USER_WORKER_DIR}/config.sh" << EOF
export CRYOSPARC_LICENSE_ID="${LICENSE_ID}"
export CRYOSPARC_MASTER_HOSTNAME="${HOST_FQDN}"
export CRYOSPARC_DB_PATH="${USER_DB_DIR}"
export CRYOSPARC_BASE_PORT=${BASE_PORT}
export CRYOSPARC_DEVELOP=false
export CRYOSPARC_INSECURE=true
export CRYOSPARC_FORCE_HOSTNAME=true
export CRYOSPARC_FORCE_USER=true
export CRYOSPARC_USE_GPU=true
EOF

# Export all the environment variables
export CRYOSPARC_LICENSE_ID="${LICENSE_ID}"
export CRYOSPARC_MASTER_HOSTNAME="${HOST_FQDN}"
export CRYOSPARC_DB_PATH="${USER_DB_DIR}"
export CRYOSPARC_BASE_PORT=${BASE_PORT}
export CRYOSPARC_DEVELOP=false
export CRYOSPARC_INSECURE=true
export CRYOSPARC_FORCE_HOSTNAME=true
export CRYOSPARC_FORCE_USER=true

# ============================================================
# IMPROVED CLEANUP TRAP: Graceful shutdown on exit
# ============================================================
cleanup() {
    echo ""
    echo "=============================================="
    echo "  Shutting down CryoSPARC gracefully..."
    echo "=============================================="
    
    # Kill backup process if running
    kill ${BACKUP_PID} 2>/dev/null || true
    
    cd "${MASTER_DIR}" 2>/dev/null || true
    
    # Try graceful stop
    ./bin/cryosparcm stop 2>/dev/null || true
    
    # Wait up to 20 seconds for MongoDB to stop cleanly
    for i in $(seq 1 20); do
        if ! pgrep -u "${USER}" -f "mongod.*cryosparc" > /dev/null 2>&1; then
            echo "CryoSPARC stopped cleanly after ${i} seconds"
            echo "$(date -Is) - Clean shutdown after ${i}s" >> "${USER_DATA_DIR}/session_log.txt"
            break
        fi
        sleep 1
    done
    
    # If still running, send SIGTERM
    if pgrep -u "${USER}" -f "mongod.*cryosparc" > /dev/null 2>&1; then
        echo "Sending SIGTERM to MongoDB..."
        pkill -u "${USER}" -f "mongod.*cryosparc" 2>/dev/null || true
        sleep 5
    fi
    
    # Last resort: SIGKILL
    if pgrep -u "${USER}" -f "mongod.*cryosparc" > /dev/null 2>&1; then
        echo "WARNING: Force killing MongoDB (may require recovery on next start)..."
        echo "$(date -Is) - Force kill required" >> "${USER_DATA_DIR}/session_log.txt"
        pkill -9 -u "${USER}" -f "mongod.*cryosparc" 2>/dev/null || true
    fi
    
    echo "Shutdown complete"
}
trap cleanup EXIT INT TERM

cd "${MASTER_DIR}"

if [ "${FRESH_INSTALL}" = true ]; then
  echo "First-time setup..."
  echo ""
  echo "=============================================="
  echo "  IMPORTANT: Your data will be stored at:"
  echo "  Database: ${USER_DB_DIR}"
  echo "  Projects: ${PROJECT_DIR}"
  echo "  These persist between sessions!"
  echo "=============================================="

  if [ -n "${FORM_PASSWORD}" ]; then
    INITIAL_PASSWORD="${FORM_PASSWORD}"
  else
    INITIAL_PASSWORD=$(openssl rand -base64 16 | tr -dc 'a-zA-Z0-9' | head -c 16)
  fi

  # Status update only
  write_connection_yml "db" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"
  sleep 2
  
  # Run install.sh from the user's symlinked master directory
  # Now it can write to config.sh and deps_hashes since they're in user's space!
  if ! ./install.sh --standalone \
    --license "${LICENSE_ID}" \
    --hostname "${HOST_FQDN}" \
    --dbpath "${USER_DB_DIR}" \
    --port "${BASE_PORT}" \
    --worker_path "${WORKER_DIR}" \
    --ssdpath "${SSD_CACHE}" \
    --initial_email "${USER_EMAIL}" \
    --initial_password "${INITIAL_PASSWORD}" \
    --initial_username "${USER}" \
    --initial_firstname "${USER}" \
    --initial_lastname "User" \
    --yes; then
    echo ""
    echo "=============================================="
    echo "  ERROR: CryoSPARC installation failed!"
    echo "=============================================="
    echo "  Check the output above for details."
    echo "  Common issues:"
    echo "  - Invalid license ID"
    echo "  - Permission denied errors (report to admin)"
    echo "  - Network connectivity issues"
    echo "=============================================="
    exit 1
  fi

  cat > "${USER_DATA_DIR}/credentials.txt" << EOF
============================================
CryoSPARC Login Credentials
Created: $(date)
============================================
Email:    ${USER_EMAIL}
Password: ${INITIAL_PASSWORD}
============================================
IMPORTANT: Your projects and data persist
between sessions. They are stored at:
- Database: ${USER_DB_DIR}
- Projects: ${PROJECT_DIR}
============================================
EOF
  chmod 600 "${USER_DATA_DIR}/credentials.txt" || true

else
  echo "Starting existing instance (database persists)..."
  echo ""
  echo "=============================================="
  echo "  Your existing data will be loaded from:"
  echo "  Database: ${USER_DB_DIR}"
  echo "  Projects: ${PROJECT_DIR}"
  echo "=============================================="

  # Status update only
  write_connection_yml "db" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"

  if ! ./bin/cryosparcm start; then
    echo ""
    echo "=============================================="
    echo "  WARNING: CryoSPARC start returned an error"
    echo "  Attempting to continue anyway..."
    echo "=============================================="
  fi
fi

# Status update only
write_connection_yml "master" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"

echo "Waiting for CryoSPARC web interface to start..."
sleep 1
# Status update only
write_connection_yml "app" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"
sleep 2

STARTUP_TIMEOUT=300
STARTUP_COUNTER=0
while [ ${STARTUP_COUNTER} -lt ${STARTUP_TIMEOUT} ]; do
  if curl -sf "http://localhost:${WEB_PORT}/" > /dev/null 2>&1; then
    echo "CryoSPARC is ready! (took ${STARTUP_COUNTER} seconds)"
    break
  fi
  STARTUP_COUNTER=$((STARTUP_COUNTER + 1))
  sleep 1
done

if ! curl -sf "http://localhost:${WEB_PORT}/" > /dev/null 2>&1; then
  echo ""
  echo "=============================================="
  echo "  ERROR: CryoSPARC did not come up"
  echo "=============================================="
  echo "  Waited ${STARTUP_TIMEOUT} seconds."
  echo "  Check logs at: ${USER_MASTER_DIR}/run/"
  echo ""
  echo "  Useful commands to debug:"
  echo "  cat ${USER_MASTER_DIR}/run/command_core.log"
  echo "  cat ${USER_MASTER_DIR}/run/database.log"
  echo "=============================================="
  exit 1
fi

# Now overwrite connection.yml with status ready and final values
GPU_LIST=$(nvidia-smi --query-gpu=index --format=csv,noheader 2>/dev/null | tr '\n' ',' | sed 's/,$//' || echo "")
GPU_COUNT=$(nvidia-smi --query-gpu=index --format=csv,noheader 2>/dev/null | wc -l || echo "0")

write_connection_yml "ready" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"
echo "Ready connection.yml written: ${SESSION_ROOT}/connection.yml"
sleep 2
echo "Connecting worker..."

# Status update only
write_connection_yml "worker" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"
sleep 2

echo ""
echo "=============================================="
echo "  Configuring Worker on Current Node"
echo "=============================================="
echo "  Current node: ${HOST_FQDN}"
echo "=============================================="

cd "${MASTER_DIR}"

# Get list of all registered workers and remove them
echo "Getting list of registered workers..."
WORKERS=$(./bin/cryosparcm cli "get_worker_nodes()" 2>/dev/null | grep -oP "'hostname':\s*'\K[^']+" || true)

if [ -n "${WORKERS}" ]; then
    echo "Removing all existing workers..."
    for worker in ${WORKERS}; do
        echo "  Removing: ${worker}"
        ./bin/cryosparcm cli "remove_scheduler_target_node('${worker}')" 2>/dev/null || true
    done
else
    echo "No existing workers found"
fi

sleep 2

# Now connect the current node as worker
cd "${WORKER_DIR}"
echo ""
echo "Connecting current node as worker: ${HOST_FQDN}"

# Set required environment variable for GPU detection
export CRYOSPARC_USE_GPU=true

./bin/cryosparcw connect \
  --worker "${HOST_FQDN}" \
  --master "${HOST_FQDN}" \
  --port "${BASE_PORT}" \
  --ssdpath "${SSD_CACHE}" \
  --lane "local" \
  --gpus "${GPU_LIST}" \
  --newlane || \
./bin/cryosparcw connect \
  --worker "${HOST_FQDN}" \
  --master "${HOST_FQDN}" \
  --port "${BASE_PORT}" \
  --ssdpath "${SSD_CACHE}" \
  --lane "local" \
  --gpus "${GPU_LIST}" \
  --update || true

sleep 2

# Verify worker is registered and show details
cd "${MASTER_DIR}"
echo ""
echo "=============================================="
echo "  Worker Registration Verification"
echo "=============================================="
./bin/cryosparcm cli "
workers = get_worker_nodes()
if workers:
    for w in workers:
        print(f\"  Hostname: {w.get('hostname', 'N/A')}\")
        print(f\"  CPUs: {w.get('cpu_count', 'N/A')}\")
        print(f\"  RAM: {w.get('ram_mb', 'N/A')} MB\")
        gpus = w.get('gpus', [])
        print(f\"  GPUs: {len(gpus)}\")
        for gpu in gpus:
            print(f\"    - {gpu.get('name', 'Unknown GPU')}\")
        print(f\"  Cache: {w.get('cache_path', 'N/A')}\")
else:
    print('  WARNING: No workers registered!')
" 2>/dev/null || echo "  Could not retrieve worker info"
echo "=============================================="

echo ""
echo "Worker configured: ${HOST_FQDN}"

# Return to ready for UI
write_connection_yml "ready" "${HOST_FQDN}" "${HOST_SHORT}" "${WEB_PORT}" "${USER_DATA_DIR}" "${PROJECT_DIR}" "${GPU_COUNT}"
sleep 2
echo ""
echo "##############################################"
echo "#    CryoSPARC READY                         #"
echo "##############################################"
echo "  Node: ${HOST_FQDN}"
echo "  Port: ${WEB_PORT}"
echo "  Credentials: ${USER_DATA_DIR}/credentials.txt"
echo "  Instance Dir: ${USER_INSTANCE_DIR}"
echo ""
echo "  YOUR DATA PERSISTS BETWEEN SESSIONS:"
echo "  - Database: ${USER_DB_DIR}"
echo "  - Projects: ${PROJECT_DIR}"
echo "##############################################"

while true; do
  sleep 300
done
